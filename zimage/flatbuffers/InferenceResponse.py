# automatically generated by the FlatBuffers compiler, do not modify
# Generated from inference_response.fbs

# namespace: forge

import typing as t
from flatbuffers import compat
from flatbuffers import util
from flatbuffers import builder
from flatbuffers import encoder
from flatbuffers.flexbuffers import Load
import flatbuffers


class InferenceResponse(object):
    __slots__ = ('_tab')

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = InferenceResponse()
        x._tab = flatbuffers.table.Table(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInferenceResponse(cls, buf, offset=0):
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def _buf(self, i: int = 0) -> bytes:
        return self._tab.Bytes

    def _tab(self, i: int = 0):
        return self._tab

    @property
    def Status(self) -> str:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return ""

    @property
    def Result(self) -> str:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return ""

    @property
    def Metadata(self) -> t.Sequence[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.StringVector(o + self._tab.Pos)
        return None

    @property
    def ImageData(self) -> t.Union[t.Sequence[t.Union[int, np.uint8]], None]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            from flatbuffers import vector_as_numpy
            from flatbuffers.util import UOffset
            size = self._tab.VectorLen(o)
            return vector_as_numpy.vector_with_bytes_as_numpy(o, self._tab.Bytes, size, np.uint8)
        return None


class InferenceResponseT(object):

    # InferenceResponseT
    def __init__(self):
        self.status = ""  # str
        self.result = ""  # str
        self.metadata = None  # t.Optional[t.Sequence[str]]
        self.imageData = None  # t.Optional[t.Sequence[t.Union[int, np.uint8]]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        inferenceResponse = InferenceResponse()
        inferenceResponse.Init(buf, pos)
        return cls.InitFromObj(inferenceResponse)

    @classmethod
    def InitFromObj(cls, inferenceResponse):
        x = InferenceResponseT()
        x._UnPack(inferenceResponse)
        return x

    # InferenceResponseT
    def _UnPack(self, inferenceResponse):
        if inferenceResponse is None:
            return
        self.status = inferenceResponse.Status
        self.result = inferenceResponse.Result
        self.metadata = inferenceResponse.Metadata
        self.imageData = inferenceResponse.ImageData

    # InferenceResponseT
    def Pack(self, builder):
        InferenceResponseStart(builder)
        InferenceResponseAddStatus(builder, self.status)
        InferenceResponseAddResult(builder, self.result)
        if self.metadata is not None:
            InferenceResponseAddMetadata(builder, self.metadata)
        if self.imageData is not None:
            InferenceResponseAddImageData(builder, self.imageData)
        inferenceResponse = InferenceResponseEnd(builder)
        return inferenceResponse


def CreateInferenceResponse(builder, status=None, result=None, metadata=None, imageData=None):
    builder.StartObject(4)
    InferenceResponseStartMetadataVector(builder, len(metadata) if metadata else 0)
    if metadata is not None:
        for i in reversed(range(len(metadata))):
            builder.PrependUOffsetTRelative(metadata[i])
    metadata_offset = builder.EndVector()
    builder.PrependUOffsetTRelativeSlot(2, metadata_offset, 0)
    if imageData is not None:
        InferenceResponseStartImageDataVector(builder, len(imageData))
        builder.PrependUint8s(imageData)
        image_data_offset = builder.EndVector()
        builder.PrependUOffsetTRelativeSlot(3, image_data_offset, 0)
    builder.PrependUOffsetTRelativeSlot(1, result, 0)
    builder.PrependUOffsetTRelativeSlot(0, status, 0)
    return builder.EndObject()


def InferenceResponseStart(builder):
    builder.StartObject(4)


def InferenceResponseAddStatus(builder, status):
    builder.PrependUOffsetTRelativeSlot(0, status, 0)


def InferenceResponseAddResult(builder, result):
    builder.PrependUOffsetTRelativeSlot(1, result, 0)


def InferenceResponseAddMetadata(builder, metadata):
    builder.PrependUOffsetTRelativeSlot(2, metadata, 0)


def InferenceResponseAddImageData(builder, imageData):
    builder.PrependUOffsetTRelativeSlot(3, imageData, 0)


def InferenceResponseEnd(builder):
    return builder.EndObject()


def InferenceResponseStartMetadataVector(builder, numElems=0):
    return builder.StartVector(4, numElems, 4)


def InferenceResponseEndMetadataVector(builder):
    return builder.EndVector()


def InferenceResponseStartImageDataVector(builder, numElems=0):
    return builder.StartVector(1, numElems, 1)


def InferenceResponseEndImageDataVector(builder):
    return builder.EndVector()
